<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Document</title>
</head>

<body></body>
<script>
  // 1.1 使用setTimeout实现一个mySetInterval;
  // https://juejin.cn/post/6844903839934447629
  function mySetInterval(callback, t) {
    callback()
    setTimeout(() => mySetInterval(callback, t), t)
  }

  var id
  function mySetInterval(callback, t) {
    // callback()
    // setTimeout(()=>mySetInterval(callback, t), t)

    // function f() {
    //   callback()
    //   setTimeout(f,t)
    // }
    // setTimeout(f, t)

    function f() {
      callback()
      id = setTimeout(f, t)
    }
    id = setTimeout(f, t)
    return id
  }

  var id = 1
  var obj = {}
  function mySetInterval(callback, t) {
    // callback()
    // setTimeout(()=>mySetInterval(callback, t), t)

    // function f() {
    //   callback()
    //   setTimeout(f,t)
    // }
    // setTimeout(f, t)

    // var id
    id++
    function f() {
      callback()
      obj[id] = setTimeout(f, t)
    }
    obj[id] = setTimeout(f, t)
    return id
  }

  // 使下面的调用每1000毫秒打印字符串'x'
  mySetInterval(() => {
    console.log("x")
  }, 1000)

  // 1.2 实现一个myClearInterval,可以终止一个mySetInterval的执行;
  // 提示：使用clearTimeout
  function myClearInterval(timer) {
    clearTimeout(obj[timer])
  }

  // usage:
  const timer = mySetInterval(() => {
    console.log("x")
  }, 1000)

  myClearInterval(timer)









  // 3
  // 业务需求中，经常有 只需要最后一次请求的结果（比如搜索）编写一个高阶函数，传递旧请求方法（执行后返回 promise），返回一个新方法。
  // 连续触发时，若上一次 promise 执行未结束则直接废弃，只有最后一次 promise 会触发then/reject。

  /**
   * 只有最后一次promise会then与reject
   * @param {function} promiseFunction
   * promiseFunction 示例： () => fetch('data')
   */

  function lastPromise(promiseFunction) {
    var queue = []
    return function f() {
      const fun = promiseFunction()
      queue.push(fun)
      return new Promise((resolve) => {
        // 下面似乎有问题？？总是为true
        if (queue.indexOf(fun) === queue.length - 1) {
          resolve(fun)
        }
      })
    }
  }

  // 示例
  let count = 1
  let promiseFunction = () =>
    new Promise((rs) =>
      window.setTimeout(() => {
        rs(count++)
      })
    )

  let lastFn = lastPromise(promiseFunction)

  lastFn().then(console.log) // 无输出
  lastFn().then(console.log) // 无输出
  lastFn().then(console.log) // 3










  // batch 一个函数，让它在并发调用时只被执行一次
  // https://www.qiyuandi.com/zhanzhang/zonghe/13965.html

  let executeCount = 0
  const targetFn = async (nums) => {
    executeCount++
    return nums.map((num) => 2 * num + 1)
  }

  // const batcher = (fn) => {
  //   // todo batch logic
  //   let queue = []
  //   let len = []
  //   // let obj = {}
  //   return function f(arr) {
  //     queue.push(arr)
  //     len.push(arr.length)
  //     // queue = queue.concat(...arr)
  //     return new Promise((resolve) => {
  //       if (queue.indexOf(arr) === queue.length - 1) {
  //         let res = fn([].concat(...queue))
  //         for (let i = 0; i < len.length; i++) {
  //           // res.slice(len[i]
  //         }
  //         resolve(res)
  //       }
  //     })
  //   }
  // }

  const batcher = (f) => {
    let nums = []
    const p = Promise.resolve().then((_) => f(nums))

    return (arr) => {
      let start = nums.length
      nums = nums.concat(arr)
      let end = nums.length
      return p.then((ret) => ret.slice(start, end))
    }
  }

  const batchedFn = batcher(targetFn)

  const main = async () => {
    const [result1, result2, result3] = await Promise.all([
      batchedFn([1, 2, 3]),
      batchedFn([4, 5]),
      batchedFn([6, 7]),
    ])

    console.log(result1, result2, result3) //
    console.log(executeCount) // 预期为 1
  }

  main()

  const fn = (...args) => {
    for (const arg of args) {
      console.log(arg)
    }
    let res = ""
    let res0 = args[0]
    for (let i = 1; i < args.length; i++) {
      res += res0[i - 1] + args[i]
    }
    return (res += res0[res0.length - 1])
  }
  const [a, b] = [1, 2]
  fn`111${a} + ${b} = ${a + b}222`

  fn("1+2=3")
    ; ("1+2=3")






  // https://github.com/slorber/awesome-only-resolves-last-promise
  function createImperativePromise(promiseArg) {
    var resolve = null
    var reject = null
    var wrappedPromise = new Promise(function (_resolve, _reject) {
      resolve = _resolve
      reject = _reject
    })
    promiseArg &&
      promiseArg.then(
        function (val) {
          resolve && resolve(val)
        },
        function (error) {
          reject && reject(error)
        }
      )
    return {
      promise: wrappedPromise,
      resolve: function (value) {
        resolve && resolve(value)
      },
      reject: function (reason) {
        reject && reject(reason)
      },
      cancel: function () {
        resolve = null
        reject = null
      },
    }
  }

  // see https://stackoverflow.com/a/54825370/82609
  function onlyResolvesLast(asyncFunction) {
    var cancelPrevious = null
    return function () {
      var args = []
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i]
      }
      cancelPrevious && cancelPrevious()
      var initialPromise = asyncFunction.apply(void 0, args)
      var _a = createImperativePromise(initialPromise),
        promise = _a.promise,
        cancel = _a.cancel
      cancelPrevious = cancel
      return promise
    }
  }
  let count = 1
  let promiseFunction = () =>
    new Promise((rs) =>
      window.setTimeout(() => {
        rs(count++)
      })
    )
  let lastFn = onlyResolvesLast(promiseFunction)
  lastFn().then(console.log) // 无输出
  lastFn().then(console.log) // 无输出
  lastFn().then(console.log) // 3

  // const delayPromise = (timeout: number) =>
  // new Promise(resolve => {
  //   setTimeout(resolve, timeout);
  // });
  //   const asyncFunction = async (arg: number, arg2: string) => {
  //   await delayPromise(delay);
  //   return `val ${arg} ${arg2}`;
  // };
  // const wrappedAsyncFunction = onlyResolvesLast(asyncFunction);
  // // When
  // const promise1 = wrappedAsyncFunction(1, '1');
  // const promise2 = wrappedAsyncFunction(2, '2');
  // const promise3 = wrappedAsyncFunction(3, '3');









  // 定义了一个同步函数对传入的数组进行遍历乘二操作，同时每执行一次就会给 executeCount 累加。最终我们需要实现一个 batcher 函数，使用其对该同步函数包装后，实现每次调用依旧返回预期的二倍结果，同时还需要保证 executeCount 执行次数为1。
  let executeCount = 0
  const fn = (nums) => {
    executeCount++
    return nums.map((x) => x * 2)
  }

  const batcher = (f) => {
    // todo 实现 batcher 函数
  }

  const batchedFn = batcher(fn)

  const main = async () => {
    const [r1, r2, r3] = await Promise.all([
      batchedFn([1, 2, 3]),
      batchedFn([4, 5]),
      batchedFn([7, 8, 9]),
    ])

    //满足以下 test case
    assert(r1).tobe([2, 4, 6])
    assert(r2).tobe([8, 10])
    assert(r3).tobe([14, 16, 18])
    assert(executeCount).tobe(1)
  }

  // setTimeout 解法
  const batcher = (f) => {
    let nums = []
    const p = new Promise((resolve) =>
      setTimeout((_) => resolve(f(nums)), 100)
    )

    return (arr) => {
      let start = nums.length
      nums = nums.concat(arr)
      let end = nums.length
      return p.then((ret) => ret.slice(start, end))
    }
  }

  // Promise 解法
  const batcher = (f) => {
    let nums = []
    const p = Promise.resolve().then((_) => f(nums))

    return (arr) => {
      let start = nums.length
      nums = nums.concat(arr)
      let end = nums.length
      return p.then((ret) => ret.slice(start, end))
    }
  }








  // 评测题目2: 实现一个LazyPig，可以按照以下方式调用:
  /* LazyPig("Peggy")输出:
Hello，I'm Peggy！
 
LazyPig("Peggy").sleep(10).eat("dinner")输出
Hello，I'm Peggy！
//等待10秒..
Wake up after 10
Eat dinner~
 
LazyPig("Peggy").eat("dinner").eat("supper")输出
Hello，I'm Peggy！
Eat dinner~
Eat supper~
 
以此类推。
*/

  // 利用promise
  function LazyPig(v) {
    return new F(v)
  }
  function F(v) {
    console.log(`Hello，I'm ${v}！`)
    this.tmp = Promise.resolve()
  }
  F.prototype = {
    sleep(t) {
      this.tmp = this.tmp.then(
        () =>
          new Promise((resolve) => {
            setTimeout(resolve, t * 1000)
          })
      )
      return this
    },
    eat(v) {
      this.tmp = this.tmp.then(() => {
        console.log(`Eat ${v}`)
      })
      return this
    },
  }
  LazyPig("Peggy").sleep(3).eat("dinner").sleep(1).eat("supper")

  // 手动构建任务数组
  function LazyPig(name) {
    return new Lazy(name)
  }
  function Lazy(name) {
    this.name = name
    this.task = []
    console.log("Hi, 我是" + name)
    let _this = this
    let fn = (function () {
      return function () {
        _this.next()
      }
    })()
    this.task.push(fn)
    setTimeout(() => {
      _this.next()
    }, 0)
  }
  Lazy.prototype = {
    next: function () {
      var fn = this.task.shift()
      fn && fn()
    },
    sleep: function (time) {
      let _this = this
      let fn = (function (time) {
        return function () {
          setTimeout(() => {
            console.log(_this.name + " Wake up !")
            _this.next()
          }, time * 1000)
        }
      })(time)
      this.task.push(fn)
      return this
    },
    eat: function (smt) {
      let _this = this
      let fn = (function (smt) {
        return function () {
          console.log(_this.name + " is eating " + smt)
          _this.next()
        }
      })(smt)
      this.task.push(fn)
      return this
    },
  }
  LazyPig("Peggy").sleep(3).eat("dinner").sleep(1).eat("supper")

  // 用while同步阻塞
  function LazyPig(name) {
    console.log(`Hello,I'm ${name}`)
    var fn = {}
    fn.sleep = function (time) {
      console.log(`Wake up ${time}s`)
      let start = Date.now()
      while (Date.now() - start <= time * 1000) { }
      console.log(`Wake up down`)
      return fn
    }
    fn.eat = function (food) {
      console.log(`Eat ${food}`)
      return fn
    }
    return fn
  }
  LazyPig("Peggy").sleep(3).eat("dinner").sleep(1).eat("supper")

  function LazyPig(name) {
    console.log(`Hello, I\'m ${name}！`)
    var arr = new Array()
    var isRec = false
    var isSteep = false
    this.sleep = function (n) {
      isSteep = true
      arr.push({
        fun: "sleep",
        val: n,
      })
      if (!isRec) {
        recursive()
      }
      return this
    }
    this.eat = function (input) {
      if (isSteep) {
        arr.push({
          fun: "eat",
          val: input,
        })
      } else {
        _eat(input)
      }
      return this
    }
    function _eat(input) {
      console.log(`Eat ${input}`)
    }
    function recursive() {
      isRec = true
      if (!!arr) {
        var obj = arr.shift()
        if (!obj) return
        if (obj.fun === "sleep") {
          console.log(`Wake up after  ${obj.val}`)
          setTimeout(function () {
            recursive()
          }, obj.val * 1000)
        } else {
          _eat(obj.val)
          recursive()
        }
      }
    }
    return this
  }
  LazyPig("Peggy").sleep(3).eat("dinner").sleep(1).eat("supper")







  // 主题：:限制最多同时异步并发请求数
  // 是需要耗费额外空间slice原数组然后一个个shift 还是用全局index剩下额外的空间。是需要count还是根本就不需要关注这些自然会保持最高并发数。是一下子处理完原数组所有值还是没用到的暂时不处理。是否需要以及如何获得与原数组一一对应的结果数组。是否递归实质上都需要递归。是async还是纯promise。


  // https://blog.csdn.net/qq_34629352/article/details/105955188
  // 将一个递归函数拆分成两个，一个函数只负责计数和发送请求，另外一个负责调度。

  // 比较好的方法非常容易理解，没有用全局index用了count，拆分了多个不同职责的函数，用递归
  var urls = Array.from({ length: 50 }).map((k, i) => "url" + i)
  var asyncGet = (v) => {
    console.log("begin:", v)
    return new Promise((resolve) => {
      setTimeout(() => {
        console.log("end:", v)
        resolve(v)
      }, 1000 * Math.random())
    })
  }

  var count = 0 //当前正在进行数
  // 封装请求的异步函数,增加计数器功能
  function request() {
    count++
    asyncGet(urls.shift())
      .then(() => {
        count--
      })
      .then(schedule)
  }
  // 负责调度的函数
  function schedule() {
    // 这里的count有必要吗？是否只需要urls.length就够了
    if (urls.length > 0 && count <= 3) {
      request()
    }
  }

  function async1() {
    for (var i = 0; i < 3; i++) {
      request()
    }
  }
  async1()



  // 比较好的方法容易理解，用了async一下子处理完了所有值也挂起了很多
  // 采用async await制造阻塞block
  var urls = Array.from({ length: 50 }).map((k, i) => "url" + i)
  var asyncGet = (v) => {
    console.log("begin:", v)
    return new Promise((resolve) => {
      setTimeout(() => {
        console.log("end:", v)
        resolve(v)
      }, 1000 * Math.random())
    })
  }
  // 计数器
  var count = 0
  // 全局锁
  var lock = []
  var l = urls.length
  // 阻塞函数
  function block() {
    // let _resolve
    return new Promise((resolve, reject) => {
      // resolve不执行,将其推入lock数组，这里不需要值，只是纯粹的阻塞用
      lock.push(resolve)
    })
  }
  // 叫号机
  function next() {
    lock.length && lock.shift()()
  }
  async function bao() {
    if (count >= 3) {
      //超过限制利用await和promise进行阻塞，一下子执行了全部
      await block()
    }
    if (urls.length > 0) {
      // console.log(count)
      count++
      await asyncGet(urls.shift())
      count--
      next()
    }
  }
  for (let i = 0; i < l; i++) {
    bao()
  }



  // https://juejin.cn/post/6989103878436290568
  // 没有用到当前运行的请求的最大index，用的是shift
  function send() {
    let total = 100
    // 初始化数组
    let initList = Array.from({ length: total }).map((k, i) => i)
    // 最大并发次数
    const limit = 5
    // 最终结果
    let result = {}
    // 已经请求完的个数
    let resultLength = 0

    //定义异步函数
    const asyncGet = (v) =>
      new Promise((resolve) => {
        setTimeout(() => resolve(v), 1000 * Math.random())
      })

    // 初始化100个异步请求函数，当闭包被执行的时候会执行一个请求，当请求执行完后，会获取下一个并执行
    // map后的每一项是一个未执行的函数
    let runningList = initList.map((item) => {
      return () => {
        return asyncGet(item).then((res) => {
          console.log("res:" + res)
          resultLength++
          result[item] = "final " + res
          let next = runningList.shift()
          if (next) {
            next()
          } else if (resultLength === total) {
            console.log(
              "全部执行完成",
              initList.map((it) => result[it]),
              result
            )
          }
        })
      }
    })
    const arr = []
    // 一次性取出最大并发数并执行
    for (let i = 0; i < limit; i++) {
      let fn = runningList.shift()
      arr.push(fn())
    }
  }
  send()



  // 15 行代码实现通用并发控制（javascript）
  /**
   * @params list {Array} - 要迭代的数组
   * @params limit {Number} - 并发数量控制数
   * @params asyncHandle {Function} - 对`list`的每一个项的处理函数，参数为当前处理项，必须 return 一个Promise来确定是否继续进行迭代
   * @return {Promise} - 返回一个 Promise 值来确认所有数据是否迭代完成
   */

  let mapLimit = (list, limit, asyncHandle) => {
    let recursion = (arr) => {
      return asyncHandle(arr.shift()).then(() => {
        if (arr.length !== 0) return recursion(arr)
        // 数组还未迭代完，递归继续进行迭代,
        // 最终会打印finish次数为limit次
        else return "finish"
      })
    }

    let listCopy = [].concat(list)
    let asyncList = [] // 正在进行的所有并发异步操作
    while (limit--) {
      asyncList.push(recursion(listCopy))
    }
  }

  // test demo
  var dataLists = [1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 100, 123]
  var count = 0
  mapLimit(dataLists, 3, (curItem) => {
    return new Promise((resolve) => {
      count++
      setTimeout(() => {
        console.log(curItem, "当前并发量:", count--)
        resolve()
      }, Math.random() * 5000)
    })
  })

  

  // 利用 Promise 封装一个异步加载图片的方法，并限制并发个数，即同时请求的个数不超过3个。
  // 采用全局index，替代采用额外的数组shift
  let count = 0
  let index = 0
  let asyncGet = (v) => {
    console.log("begin:", v)
    return new Promise((resolve) => {
      setTimeout(() => {
        console.log("end:", v)
        resolve(v)
      }, 1000 * Math.random())
    })
  }
  // 用的全局index
  function loadControl(arr) {
    if (index >= arr.length) return
    if (count < 3) {
      console.log(count, index)
      count++
      asyncGet(arr[index])
        .then(() => {
          count--
        })
        .then(() => loadControl(arr, ++index))
    }
  }
  let arr = Array.from({ length: 50 }).map((k, i) => "url" + i)
  // 这里要同时调用limit次
  loadControl(arr)
  loadControl(arr)
  loadControl(arr)



  // https://github.com/rxaviers/async-pool
  // es7版本 用 async await Promise.all Promise.race 还能得到与原数组对应的最终结果数组，不需要用全局index 不需要slice原数组又shift 不需要递归
  async function asyncPool(poolLimit, array, iteratorFn) {
    const ret = []; // 存储所有的异步任务
    const executing = []; // 存储正在执行的异步任务
    for (const item of array) {
      // 调用iteratorFn函数创建异步任务
      const p = Promise.resolve().then(() => iteratorFn(item, array));
      ret.push(p); // 保存新的异步任务

      // 当poolLimit值小于或等于总任务个数时，进行并发控制
      if (poolLimit <= array.length) {
        // 当任务完成后，从正在执行的任务数组中移除已完成的任务
        const e = p.then(() => executing.splice(executing.indexOf(e), 1));
        executing.push(e); // 保存正在执行的异步任务
        if (executing.length >= poolLimit) {
          await Promise.race(executing); // 等待较快的任务执行完成
        }
      }
    }
    return Promise.all(ret);
  }

  const timeout = i => new Promise(resolve => setTimeout(() => resolve(i), i));
  await asyncPool(2, [1000, 5000, 3000, 2000], timeout);
  // Call iterator (i = 1000)
  // Call iterator (i = 5000)
  // Pool limit of 2 reached, wait for the quicker one to complete...
  // 1000 finishes
  // Call iterator (i = 3000)
  // Pool limit of 2 reached, wait for the quicker one to complete...
  // 3000 finishes
  // Call iterator (i = 2000)
  // Itaration is complete, wait until running ones complete...
  // 5000 finishes
  // 2000 finishes
  // Resolves, results are passed in given array order `[1000, 5000, 3000, 2000]`.


  // es6版本 用 then Promise.all Promise.race 需要全局index 需要递归但是并没有一下子执行了一大串then
  function asyncPool(poolLimit, array, iteratorFn) {
    let i = 0;
    const ret = []; // 存储所有的异步任务
    const executing = []; // 存储正在执行的异步任务
    const enqueue = function () {
      if (i === array.length) {
        return Promise.resolve();
      }
      const item = array[i++]; // 获取新的任务项
      const p = Promise.resolve().then(() => iteratorFn(item, array));
      ret.push(p);

      let r = Promise.resolve();

      // 当poolLimit值小于或等于总任务个数时，进行并发控制
      if (poolLimit <= array.length) {
        // 当任务完成后，从正在执行的任务数组中移除已完成的任务
        const e = p.then(() => executing.splice(executing.indexOf(e), 1));
        executing.push(e);
        if (executing.length >= poolLimit) {
          r = Promise.race(executing);
        }
      }

      // 正在执行任务列表 中较快的任务执行完成之后，才会从array数组中获取新的待办任务
      // 这里不是一下子接了一大串then而是递归一个个接上then方法，也会有race带来的长时间阻塞，后面的then串不需要接住前一个的res，如果一下子执行一串then方法则需要后面的接住前面的res
      return r.then(() => enqueue());
    };
    // all最先接上但是却是等递归结束后最后才执行
    return enqueue().then(() => Promise.all(ret));
  }
  const timeout = i => new Promise(resolve => setTimeout(() => resolve(i), i));
  asyncPool(2, [1000, 5000, 3000, 2000], timeout).then(results => { });


  // 用 Promise.race来实现，先并发请求3个图片资源，这样可以得到 3 个 Promise实例，组成一个数组promises ，然后不断的调用 Promise.race 来返回最快改变状态的 Promise，然后从数组（promises ）中删掉这个 Promise 对象实例，再加入一个新的 Promise实例，直到全部的 url 被取完。

  function limitLoad(urls, handler, limit) {
    // 对数组做一个拷贝
    const sequence = [].concat(urls)
    let promises = []

    //并发请求到最大数
    promises = sequence.splice(0, limit).map((url, index) => {
      // 这里返回的 index 是任务在 promises 的脚标，
      //用于在 Promise.race 之后找到完成的任务脚标
      return handler(url).then(() => {
        return index
      })
    })
      ; (async function loop() {
        let p = Promise.race(promises)
        for (let i = 0; i < sequence.length; i++) {
          // 一下子执行了一串所有的then方法 需要接住上一个的res
          p = p.then((res) => {
            promises[res] = handler(sequence[i]).then(() => {
              return res
            })
            return Promise.race(promises)
          })
        }
      })()
  }
  // limitLoad(dataLists, loadImg, 3)

</script>

</html>
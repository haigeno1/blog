<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script src="">
    // 合并有序链表 递归 非递归
    // https://blog.csdn.net/seu_lxy/article/details/89162397

    function Merge(pHead1, pHead2)//每次参加递归的头指针
    {
      var p = null;   //每次链接到新链表的节点，初始化为空 
      if (pHead1 === null) {
        return pHead2;   //特殊情况，递归出口
      }
      if (pHead2 === null) {
        return pHead1;
      }
      if (pHead1.val < pHead2.val) {
        p = pHead1;
        p.next = Merge(pHead1.next, pHead2);
      } else {
        p = pHead2;
        p.next = Merge(pHead1, pHead2.next);
      }
      return p; //回溯后，这个p就是pHead1或者pHead2，链表头指针
    }

    function Merge(pHead1, pHead2) {
      var res;
      var p1 = pHead1;
      var p2 = pHead2;
      if (p1 === null) { return p2; }
      if (p2 === null) { return p1; }
      //确定新链表头指针，链表要以头指针返回
      if (p1.val < p2.val) {
        res = p1;
        p1 = p1.next;
      } else {
        res = p2;   //res为合并后链表的头,接下来只要依次将元素链接上即可
        p2 = p2.next;
      }
      var cur = res;//当前链表的结尾节点
      while (p1 !== null && p2 !== null) {
        if (p1.val < p2.val) {
          cur.next = p1;//将p1链接到当前链表末尾
          cur = p1;//末尾更新，后移
          p1 = p1.next;//需要合并的节点后移
        } else {
          cur.next = p2;
          cur = p2;
          p2 = p2.next;
        }
      }
      if (p1 !== null) { //p2已经空了，跳出while循环，将p1为头指针的后续链表连接上
        cur.next = p1;
      }
      if (p2 !== null) {  //p1已经空了，跳出while循环，将p2为头指针的后续链表连接上
        cur.next = p2;
      }
      return res;
    }



    
    // 反转链表 https://blog.csdn.net/weixin_36769175/article/details/81165741
    var reverseList = function (head) {
      var list = head;
      var p = list;
      var q = null;

      if (p == null)
        return null;

      while (p.next !== null) {
        q = p.next;
        p.next = q.next;
        q.next = list;
        list = q;
      }
      return list;
    };


    // https://leetcode.com/submissions/detail/227953017/

    var lengthOfLIS = function(nums) {
      let dp = new Array(nums.length).fill(1)
      let max = 0
      for (let i = 0; i < nums.length; i++){
          for (let j = 0; j < i; j++){
              if(nums[j] < nums[i]){
                  dp[i] = Math.max(dp[i], dp[j] + 1)
              }
          }
          max = Math.max(max, dp[i])
      }
      return max
    };

    var lengthOfLIS = function(nums) {
      if (nums.length < 2) return nums.length;
      const d = [1];
      let maxAns = 1;
      for (let i=1; i<nums.length; i++) {
          let len = 0;
          for (let j=0;j<d.length;j++) {
              if (nums[i] > nums[j]) {
                  len = Math.max(len, d[j]);
              }
          }
          d[i] = len + 1;
          maxAns = Math.max(maxAns, d[i])
      }
      return maxAns;
    };





    // 回溯
    // 假设有一个集合 ['foo', 'bar', 'hello', 'world']，求这个集合里单词组合起来的所有不同的结果，比如：

    // foobarhelloworld
    // barfoohelloworld
    let arr = ['foo', 'hello', 'world']
    let result = []
    var count = 0
    function backtracking(res=[]) {
        for (let i = 0; i < arr.length; i++) {
            if(res.indexOf(arr[i]) === -1) {
                res.push(arr[i])
                console.log("after push", res)
                if (res.length === arr.length) {
                  count++
                  result.push(res.join(""))
                  console.log("count:",count,res)
                } else {
                    backtracking(res)
                }
                res.pop()
                console.log("after pop", res)
            }
        }
    }
    backtracking([])



// 螺旋打印二维数组

    /**
 * @param {number[][]} matrix
 * @return {number[]}
 */
// var spiralOrder = function(matrix) {
//   if(matrix.length < 1 || matrix[0].length < 2) return matrix
//   let spiral =[]
//   let startY = 0
//   let endY = matrix[0].length-1
//   let startX = 0
//   let endX = matrix.length-1
//   while(startX <= endX && startY <= endY) {
//       for(let i = startY ; i<=endY ; i++) {
//           spiral.push(matrix[startX][i])
//       }
//       if(startX == endX) break
//       for(let i = startX+1;i<=endX;i++) {
//           spiral.push(matrix[i][endY])
//       }
//       for(let i = endY-1;i>=startY;i--) {
//           spiral.push(matrix[endX][i])
//       }
//       if(startY == endY) break      
//       for(let i = endX-1;i>=startY+1;i--){
//           spiral.push(matrix[i][startY])
//       }
//       startY++
//       endY--
//       startX++
//       endX--
//   }
//   return spiral
// };



// var spiralOrder = function(matrix) {
//     let res = []
//     while(matrix.length>0) {  // cut the top->right->bottom->left sides until matrix is empty
//         let top = matrix.shift()
//         let bottom = (matrix.pop() || []).reverse()
//         let left = [], right = []
//         for (let i=0; i<matrix.length; i++) {
//             if (matrix[i].length>0) right.push( matrix[i].pop() )
//             if (matrix[i].length>0) left.unshift( matrix[i].shift())
//         }
//         res.push(...top,...right,...bottom,...left)
//     }
//     return res
// };




// var spiralOrder = function(matrix) {
//     const m = matrix.length;
//     const n = matrix[0].length;
//     const dx = [0, 1, 0, -1];
//     const dy = [1, 0, -1, 0];
//     const answer = [];
//     const visit = Array.from(Array(m), () => Array(n).fill(false));
    
//     function inRange(x, y) {
//         return (0 <= x && x < m && 0 <= y && y < n);
//     }
    
//     function dfs(x, y, dir) {
//         if (!inRange(x, y) || visit[x][y]) return;
        
//         visit[x][y] = true;
//         answer.push(matrix[x][y]);
        
//         let nx = x + dx[dir];
//         let ny = y + dy[dir];
        
//         if (inRange(nx, ny) && !visit[nx][ny]) {
//             dfs(nx, ny, dir);
//         } else {
//             dir = (dir + 1) % 4;
//             nx = x + dx[dir];
//             ny = y + dy[dir];
            
//             dfs(nx, ny, dir);
//         }
//     }
    
//     dfs(0, 0, 0);
    
//     return answer;
// };

  </script>
</body>

</html>
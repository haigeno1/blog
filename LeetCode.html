<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script src="">
    // 合并有序链表 递归 非递归
    // https://blog.csdn.net/seu_lxy/article/details/89162397

    function Merge(pHead1, pHead2)//每次参加递归的头指针
    {
      var p = null;   //每次链接到新链表的节点，初始化为空 
      if (pHead1 === null) {
        return pHead2;   //特殊情况，递归出口
      }
      if (pHead2 === null) {
        return pHead1;
      }
      if (pHead1.val < pHead2.val) {
        p = pHead1;
        p.next = Merge(pHead1.next, pHead2);
      } else {
        p = pHead2;
        p.next = Merge(pHead1, pHead2.next);
      }
      return p; //回溯后，这个p就是pHead1或者pHead2，链表头指针
    }

    function Merge(pHead1, pHead2) {
      var res;
      var p1 = pHead1;
      var p2 = pHead2;
      if (p1 === null) { return p2; }
      if (p2 === null) { return p1; }
      //确定新链表头指针，链表要以头指针返回
      if (p1.val < p2.val) {
        res = p1;
        p1 = p1.next;
      } else {
        res = p2;   //res为合并后链表的头,接下来只要依次将元素链接上即可
        p2 = p2.next;
      }
      var cur = res;//当前链表的结尾节点
      while (p1 !== null && p2 !== null) {
        if (p1.val < p2.val) {
          cur.next = p1;//将p1链接到当前链表末尾
          cur = p1;//末尾更新，后移
          p1 = p1.next;//需要合并的节点后移
        } else {
          cur.next = p2;
          cur = p2;
          p2 = p2.next;
        }
      }
      if (p1 !== null) { //p2已经空了，跳出while循环，将p1为头指针的后续链表连接上
        cur.next = p1;
      }
      if (p2 !== null) {  //p1已经空了，跳出while循环，将p2为头指针的后续链表连接上
        cur.next = p2;
      }
      return res;
    }



    
    // 反转链表 https://blog.csdn.net/weixin_36769175/article/details/81165741
    var reverseList = function (head) {
      var list = head;
      var p = list;
      var q = null;

      if (p == null)
        return null;

      while (p.next !== null) {
        q = p.next;
        p.next = q.next;
        q.next = list;
        list = q;
      }
      return list;
    };


    // https://leetcode.com/submissions/detail/227953017/

    var lengthOfLIS = function(nums) {
      let dp = new Array(nums.length).fill(1)
      let max = 0
      for (let i = 0; i < nums.length; i++){
          for (let j = 0; j < i; j++){
              if(nums[j] < nums[i]){
                  dp[i] = Math.max(dp[i], dp[j] + 1)
              }
          }
          max = Math.max(max, dp[i])
      }
      return max
    };

    var lengthOfLIS = function(nums) {
      if (nums.length < 2) return nums.length;
      const d = [1];
      let maxAns = 1;
      for (let i=1; i<nums.length; i++) {
          let len = 0;
          for (let j=0;j<d.length;j++) {
              if (nums[i] > nums[j]) {
                  len = Math.max(len, d[j]);
              }
          }
          d[i] = len + 1;
          maxAns = Math.max(maxAns, d[i])
      }
      return maxAns;
    };





    // 回溯
    // 假设有一个集合 ['foo', 'bar', 'hello', 'world']，求这个集合里单词组合起来的所有不同的结果，比如：

    // foobarhelloworld
    // barfoohelloworld
    let arr = ['foo', 'hello', 'world']
    let result = []
    var count = 0
    function backtracking(res=[]) {
        for (let i = 0; i < arr.length; i++) {
            if(res.indexOf(arr[i]) === -1) {
                res.push(arr[i])
                console.log("after push", res)
                if (res.length === arr.length) {
                  count++
                  result.push(res.join(""))
                  console.log("count:",count,res)
                } else {
                    backtracking(res)
                }
                res.pop()
                console.log("after pop", res)
            }
        }
    }
    backtracking([])



// 螺旋打印二维数组
    // #include<iostream>
    // using namespace std;

    // int     arr[6][5]= 
    // {{1,           16,           3,           2,             17}, 
    // {8,           6,             4,           3,             23}, 
    // {2,           5,             7,           8,             12}, 
    // {21,         2,             4,           6,             13}, 
    // {11,       111,           111,       132,         12}, 
    // {31,       311,           4111,     332,         32} 
    // };      
//     输入m * n的二维矩阵，要求从(0,0)开始螺旋向内完成打印输出。 具体打印方法： 1. ➡️先从左向右打印第一行； 2. ⤵️再从上向下打印最后一列； 3. ⬅️然后从右向左打印最后一行； 4. ⤴️最后从下向上打印第一列。
// 如此往复，完成所有元素打印。
// 例如：
// input = [
//  [ 1,  2,  3,  4,  5],
// [14, 15, 16, 17,  6],
// [13, 20, 19, 18,  7],
// [12, 11, 10,  9,  8],
// ]

// output = 
// 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20
    // void main()
    // {
    //         // 初始的区间坐标
    //     int startX = 0, endX = 4;
    //     int startY = 0, endY = 5;
        
    //     while(startX<=endX && startY<=endY)  // 循环条件
    //     {
    //         int i;
    //         for(i=startX; i<=endX; i++)  // 输出上边的行
    //             cout << arr[startY][i] << " ";
    //         startY ++;         // 行的开始坐标增加
    //         for(i=startY; i<=endY; i++)  // 输出右边的列
    //             cout << arr[i][endX] << " ";
    //         endX --;           // 列的结束坐标减小
    //         for(i=endX; i>=startX; i--)   // 输出下边边的行
    //             cout << arr[endY][i] << " ";
    //         endY --;           // 行的结束坐标减小
    //         for(i=endY; i>=startY; i--)  // 输出左边的列
    //             cout << arr[i][startX] << " ";
    //         startX ++;         // 列的开始坐标增加
    //     }
    // }


    /**
 * @param {number[][]} matrix
 * @return {number[]}
 */
// var spiralOrder = function(matrix) {
//   if(matrix.length < 1 || matrix[0].length < 2) return matrix
//   let spiral =[]
//   let startY = 0
//   let endY = matrix[0].length-1
//   let startX = 0
//   let endX = matrix.length-1
//   while(startX <= endX && startY <= endY) {
//       for(let i = startY ; i<=endY ; i++) {
//           spiral.push(matrix[startX][i])
//       }
//       if(startX == endX) break
//       for(let i = startX+1;i<=endX;i++) {
//           spiral.push(matrix[i][endY])
//       }
//       for(let i = endY-1;i>=startY;i--) {
//           spiral.push(matrix[endX][i])
//       }
//       if(startY == endY) break      
//       for(let i = endX-1;i>=startY+1;i--){
//           spiral.push(matrix[i][startY])
//       }
//       startY++
//       endY--
//       startX++
//       endX--
//   }
//   return spiral
// };
    /**
 * @param {number[][]} matrix
 * @return {number[]}
 */
// var spiralOrder = function(matrix) {
//     const m = matrix.length;
//     const n = matrix[0].length;
//     const dx = [0, 1, 0, -1];
//     const dy = [1, 0, -1, 0];
//     const answer = [];
//     const visit = Array.from(Array(m), () => Array(n).fill(false));
    
//     function inRange(x, y) {
//         return (0 <= x && x < m && 0 <= y && y < n);
//     }
    
//     function dfs(x, y, dir) {
//         if (!inRange(x, y) || visit[x][y]) return;
        
//         visit[x][y] = true;
//         answer.push(matrix[x][y]);
        
//         let nx = x + dx[dir];
//         let ny = y + dy[dir];
        
//         if (inRange(nx, ny) && !visit[nx][ny]) {
//             dfs(nx, ny, dir);
//         } else {
//             dir = (dir + 1) % 4;
//             nx = x + dx[dir];
//             ny = y + dy[dir];
            
//             dfs(nx, ny, dir);
//         }
//     }
    
//     dfs(0, 0, 0);
    
//     return answer;
// };

  </script>
</body>

</html>
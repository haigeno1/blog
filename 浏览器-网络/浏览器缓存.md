// https://juejin.cn/post/6844903634002509832


前端面试常问第二大问题是http缓存相关内容。说真的，http缓存相关的细节比较多，并且 http 常用协议版本有1.0、1.1，（本文暂不讨论http2.0）。
缓存相关 header
我们先罗列一下和缓存相关的请求响应头。

Expires


响应头，代表该资源的过期时间。


Cache-Control


请求/响应头，缓存控制字段，精确控制缓存策略。


If-Modified-Since


请求头，资源最近修改时间，由浏览器告诉服务器。


Last-Modified


响应头，资源最近修改时间，由服务器告诉浏览器。


Etag


响应头，资源标识，由服务器告诉浏览器。


If-None-Match


请求头，缓存资源标识，由浏览器告诉服务器。

配对使用的字段：

If-Modified-Since 和 Last-Modified
Etag 和 If-None-Match

今天着重介绍一下浏览器缓存机制，我们知道，浏览器缓存一般都是针对静态资源，比如 js、css、图片 等，所以我们下面的例子围绕一个 javascript 文件 a.js 来阐述。抛开理论式灌输，我们从实际场景触发，一点点完善缓存机制，这种方式，相信大家会更容易理解。
做一些约定，方便以后比较。

a.js 大小为 10 KB
请求头约定为 1 KB
响应头约定为 1 KB

原始模型

浏览器请求静态资源 a.js。（请求头：1KB）
服务器读取磁盘文件 a.js，返给浏览器。（10KB（a.js）+1KB（响应头） = 11KB）。
浏览器再次请求，服务器又重新读取磁盘文件 a.js，返给浏览器。
如此循环。。

执行一个往返，流量为 10（a.js）+1（请求头）+1（响应头） = 12KB。
访问 10 次，流量大约为12 * 10 = 120KB。
所以，流量与访问次数有关：
L（流量） = N（访问次数） * 12。
该方式缺点很明显：

浪费用户流量。
浪费服务器资源，服务器要读磁盘文件，然后发送文件到浏览器。
浏览器要等待 a.js 下载并且执行后才能渲染页面，影响用户体验。


js 执行时间相比下载时间要快的多，如果能优化下载时间，用户体验会提升很多。

浏览器增加缓存机制

浏览器第一次请求 a.js，缓存 a.js 到本地磁盘。（1+10+1 =12KB）
浏览器再次请求 a.js，直接走浏览器缓存（200，from cache），不再向服务器发起请求。（0KB）
...

第一次访问，流量为 1+10+1 = 12KB。
第二次访问，流量为 0。
。。。
第 10000 次访问，流量依然为 0。
所以流量与访问次数无关：
L（流量） = 12KB。
优点：

大大减少带宽。
由于减少了 a.js 下载时间，相应的提高了用户体验。

缺点：服务器上 a.js 更新时，浏览器感知不到，拿不到最新的 js 资源。
服务器和浏览器约定资源过期时间。
服务器和浏览器约定文件过期时间，用 Expires 字段来控制，时间是 GMT 格式的标准时间，如 Fri, 01 Jan 1990 00:00:00 GMT。

浏览器第一次请求一个静态资源 a.js。（1KB）
服务器把 a.js 和 a.js 的缓存过期时间(Expires：Mon, 26 Sep 2018 05:00:00 GMT)发给浏览器。（10+1=11KB）


服务器告诉浏览器：你把我发给你的 a.js 文件缓存到你那里，在 2018年9月26日5点之前不要再发请求烦我，直接使用你自己缓存的 a.js 就行了。


浏览器接收到 a.js，同时记住了过期时间。
在2018年9月26日5点之前，浏览器再次请求 a.js，便不再请求服务器，直接使用上一次缓存的 a.js 文件。（0KB）
在2018年9月26日5点01分，浏览器请求 a.js，发现 a.js 缓存时间过了，于是不再使用本地缓存，而是请求服务器，服务器又重新读取磁盘文件 a.js，返给浏览器，同时告诉浏览器一个新的过期时间。（1+10+1=12KB）。
如此往复。。。

该种方式较之前的方式有了很大的改善：

在过期时间以内，为用户省了很多流量。
减少了服务器重复读取磁盘文件的压力。
缓存过期后，能够得到最新的 a.js 文件。

缺点还是有：

缓存过期以后，服务器不管 a.js有没有变化，都会再次读取 a.js文件，并返给浏览器。

服务器告诉浏览器资源上次修改时间。
为了解决上个方案的问题，服务器和浏览器经过磋商，制定了一种方案，服务器每次返回 a.js 的时候，还要告诉浏览器 a.js 在服务器上的最近修改时间 Last-Modified （GMT标准格式）。


浏览器访问 a.js 文件。（1KB）


服务器返回 a.js 的时候，告诉浏览器 a.js 文件。（10+1=11KB） 在服务器的上次修改时间 Last-Modified（GMT标准格式）以及缓存过期时间 Expires（GMT标准格式）


当 a.js 过期时，浏览器带上 If-Modified-Since（等于上一次请求的Last-Modified） 请求服务器。（1KB）


服务器比较请求头里的 Last-Modified 时间和服务器上 a.js的上次修改时间：

如果一致，则告诉浏览器：你可以继续用本地缓存（304）。此时，服务器不再返回 a.js 文件。（1KB）
如果不一致，服务器读取磁盘上的 a.js 文件返给浏览器，同时告诉浏览器 a.js 的最近的修改时间 Last-Modified 以及过期时间 Expires。（1+10=11KB）
如此往复。



此种方案比上一个方案有了更进一步的优化：

缓存过期后，服务器检测如果文件没变化，不再把a.js发给浏览器，省去了 10KB 的流量。
缓存过期后，服务器检测文件有变化，则把最新的 a.js 发给浏览器，浏览器能够得到最新的 a.js。

缺点：

Expires 过期控制不稳定，因为浏览器端可以随意修改时间，导致缓存使用不精准。
Last-Modified 过期时间只能精确到秒。

精确到秒存在两个问题：

1、如果 a.js 在一秒时间内经常变动，同时服务器给 a.js  设置无缓存，那浏览器每次访问 a.js，都会请求服务器，此时服务器比较发给浏览器的上次修改时间和 a.js 的最近修改时间，发现都是在同一时间（因为精确到秒），因此返回给浏览器继续使用本地缓存的消息（304），但事实上服务器上的 a.js 已经改动了好多次了。所以这种情况，浏览器拿不到最新的 a.js 文件。
2、如果在服务器上 a.js 被修改了，但其实际内容根本没发生改变，会因为 Last-Modified 时间匹配不上而重新返回 a.js 给浏览器。

继续改进，增加相对时间的控制，引入 Cache-Contorl
为了兼容已经实现了上述方案的浏览器，同时加入新的缓存方案，服务器除了告诉浏览器 Expires ，同时告诉浏览器一个相对时间 Cache-Control：max-age=10秒。意思是在10秒以内，使用缓存到浏览器的 a.js 资源。
浏览器先检查 Cache-Control，如果有，则以 Cache-Control 为准，忽略 Expires。如果没有 Cache-Control，则以 Expires 为准。
继续改进，增加文件内容对比，引入Etag
为了解决文件修改时间只能精确到秒带来的问题，我们给服务器引入 Etag 响应头，a.js 内容变了，Etag 才变。内容不变，Etag 不变，可以理解为 Etag 是文件内容的唯一 ID。
同时引入对应的请求头 If-None-Match，每次浏览器请求服务器的时候，都带上If-None-Match字段，该字段的值就是上次请求 a.js 时，服务器返回给浏览器的 Etag。

浏览器请求 a.js。
服务器返回 a.js，同时告诉浏览器过期绝对时间（Expires）以及相对时间（Cache-Control：max-age=10），以及a.js上次修改时间Last-Modified，以及 a.js 的Etag。
10秒内浏览器再次请求 a.js，不再请求服务器，直接使用本地缓存。
11秒时，浏览器再次请求 a.js，请求服务器，带上上次修改时间 If-Modified-Since 和上次的 Etag 值 If-None-Match。
服务器收到浏览器的If-Modified-Since和Etag，发现有If-None-Match，则比较 If-None-Match 和 a.js 的 Etag 值，忽略If-Modified-Since的比较。
a.js 文件内容没变化，则Etag和If-None-Match 一致，服务器告诉浏览器继续使用本地缓存（304）。
如此往复。

结束了吗？
到此就结束了吗？
是的，http的缓存机制就是如此了，但是仍然存在一个问题：
浏览器无法主动得知服务器上的 a.js 资源变化了。
不管用 Expires 还是 Cache-Control，他们都只能够控制缓存是否过期，但是在缓存过期之前，浏览器是无法得知服务器上的资源是否变化的。只有当缓存过期后，浏览器才会发请求询问服务器。
最终方案
大家可以想象我们使用 a.js 的场景，我们一般都是输入网址，访问一个 html 文件，html文件中会引入 js、css
、图片等资源。
所以呢，我们在html上做些手脚。
我们不让 html 文件缓存，每次访问 html 都去请求服务器。所以浏览器每次都能拿到最新的html资源。
a.js 内容更新的时候，我们修改一下 html 中 a.js 的版本号。

第一次访问 html

<script src="http://test.com/a.js?version=0.0.1"></script>
复制代码

浏览器下载0.0.1版本的a.js文件。


浏览器再次访问 html，发现还是0.0.1版本的a.js文件，则使用本地缓存。


某一天a.js变了，我们的html文件也相应变化如下：


<script src="http://test.com/a.js?version=0.0.2"></script>
复制代码
浏览器再次访问html，发现【test.com/a.js?versio… a.js。
如此往复。

所以，通过设置html不缓存，html引用资源内容变化则改变资源路径的方式，就解决了无法及时得知资源更新的问题。
当然除了以版本号来区分，也可以以 MD5hash 值来区分。
如
<script src="http://test.com/a.【hash值】.js"></script>
复制代码使用webpack打包的话，借助插件可以很方便的处理。
除此以外的东东
Cache-Control 除了可以设置 max-age 相对过期时间以外，还可以设置成如下几种值：

public，资源允许被中间服务器缓存。


浏览器请求服务器时，如果缓存时间没到，中间服务器直接返回给浏览器内容，而不必请求源服务器。


private，资源不允许被中间代理服务器缓存。


浏览器请求服务器时，中间服务器都要把浏览器的请求透传给服务器。


no-cache，浏览器不做缓存检查。


每次访问资源，浏览器都要向服务器询问，如果文件没变化，服务器只告诉浏览器继续使用缓存（304）。


no-store，浏览器和中间代理服务器都不能缓存资源。


每次访问资源，浏览器都必须请求服务器，并且，服务器不去检查文件是否变化，而是直接返回完整的资源。


must-revalidate，可以缓存，但是使用之前必须先向源服务器确认。
proxy-revalidate，要求缓存服务器针对缓存资源向源服务器进行确认。
s-maxage：缓存服务器对资源缓存的最大时间。

Cache-Control 对缓存的控制粒度更细，包括缓存代理服务器的缓存控制。
文章介绍到此，如有兴趣，可以动手实践下。

作者：lucefer
链接：https://juejin.cn/post/6844903634002509832
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。








// https://kb.hcysun.me/#/note/http/cache

浏览器缓存策略
请求资源时缓存的应用过程
浏览器在加载资源时根据 http header 判断是否命中强缓存，如果命中，则直接使用缓存里的资源，不会发送请求到服务器。

如果没有命中强缓存，浏览器会发送请求到服务器，服务器根据 http header 判断是否命中协商缓存，如果命中则浏览器会响应这个请求，但不会返回资源，会告诉浏览器使用缓存里的资源。

如果协商缓存也没有命中，那么正常响应请求，返回资源。

强缓存和协商缓存的区别与联系
区别：命中强缓存不会发送请求到服务器，但是协商缓存需要向服务器发送请求(因为是否命中协商缓存由服务器判断)

共同点：都是从浏览器的缓存中获取资源

强缓存
开启强缓存需要 http 响应头中包含指定的字段：Expires 或 Cache-Control。

Expires
Expires 的特点
Expires 是 http1.0 提出一个表示资源过期的 respone header 字段，他有以下特点：

返回的是绝对时间。
GMT格式的字符串表示，如：Thu, 31 Dec 2037 23:55:55 GMT
Expires 的原理
Expires 字段的原理是：浏览器第一次请求资源的时候，服务器在 response header 中添加 Expires 字段，浏览器将请求回来的资源以及 response header 一并存到缓存中，当浏览器再次请求这个资源的时候，先从缓存中找到该资源，然后拿到上次缓存的 Expires 字段的值，与当前请求的时间作比较，如果发现当前请求的时间晚于上一次的 Expires 字段的值，说明缓存失效了，重新请求资源，并更新 Expires 字段的值。

Expires 存在的问题
在介绍 Expires 的特点时我们知道，Expires 字段的值代表未来的一个绝对时间，比如 2018年1月1日，这会有什么问题呢？其实很明显，如果我本机时间与服务器时间相差较大的时候，Expires 过期很容易失效了。

Cache-Control
Cache-Control 的特点
正因为 Expires 的绝对时间存在上述的问题，http1.1 提出了一个新的 respone header 即：Cache-Control，它具有以下特点：

返回的是相对时间
可以通过 Cache-Control 字段的属性值 max-age 配置缓存的时间长度，单位是秒，如下：
Cache-Control:max-age=315360000
Cache-Control 的原理
Cache-Control 缓存的原理与 Expires 类似，区别在于过期判断：

Expires 是使用本机时间与服务器返回的一个绝对时间对比，这会出问题，上面也有讲过

Cache-Control 则不同，它是使用上一次请求的时间加上设置的相对时间，计算出一个过期时间，与本次请求的时间作对比，使用的时间都是本机时间。

注意事项
Expires 与 Cache-Control 可以同时存在于 respone header，Cache-Control 的优先级高于 Expires。

协商缓存
浏览器自身就可以判断是否命中强缓存，但是协商缓存是由服务器来判断的，所以当强缓存没有命中后，浏览器会发送请求到服务器，服务器根据相应的 http header 判断是否命中协商缓存。如果命中协商缓存，则响应头的状态码为 304 即未改变(Not Modified)，告诉浏览器使用缓存中的资源。

开启协商缓存有两种方案：

请求头：If-Modified-Since 配合 响应头：Last-Modified
请求头：If-None-Match 配合 响应头：ETag
Last-Modified / If-Modified-Since
原理
当浏览器第一次向服务器请求资源时，服务器在响应头中会添加 Last-Modified 字段，该字段的值代表资源的最后一次修改时间。

浏览器再向服务器发送请求时，会在请求头部添加字段：If-Modified-Since，该字段的值为之前缓存下来的 Last-Modified 的值。

服务器拿到 If-Modified-Since 的值进行对比，如果一致则命中协商缓存，返回 304 状态码，告诉浏览器从缓存中获取资源。

如果没有命中协商缓存，则正常返回资源，以及新的 Last-Modified 值，浏览器进行更新。

注意：在命中协商缓存的情况下，服务器不会在响应头中添加：Last-Modified 字段，因为没有必要。

缺点
有的时候会出现这种情况：资源实际已经被修改了，但是他的最后修改时间没有变，这就会导致新的资源无法得到更新

ETag / If-None-Match
正如 Last-Modified / If-Modified-Since 的缺点所描述的那样，为了避免这个问题，就有了 ETag / If-None-Match。

原理
原理类似于 Last-Modified / If-Modified-Since，不同的时候，ETag 不是资源的最后修改时间，而是服务器根据当前请求的资源生成的唯一标示，是一个字符串。

Last-Modified 与 ETag 的对比
字段值
Last-Modified 是资源的最后修改时间
ETag 是当前请求的资源的唯一标示字符串
命中缓存后是否最为响应头返回
如果命中协商缓存，Last-Modified 并不会最为响应头返回，因为没有必要
如果命中协商缓存，ETag 仍然会作为响应头返回，因为不管资源有没有改变，资源的唯一标示又重新生成了。
如何利用缓存（待续...）





<!-- https://github.com/youngwind/blog/issues/113 -->
强缓存和协商缓存 这种浏览器缓存（我称之为 Header 缓存）有两个共同的缺点：
当没有网络的时候，应用无法访问，因为 HTML 页面总得去服务器获取。
缓存不可编程，无法通过 JS 来精细地对缓存进行增删改查。


一直以来，一个网页只会有两个线程：GUI 渲染线程和 JS 引擎线程。即便你的 JS 写得再天花乱坠，也只能在一个进程里面执行。然而，JS 引擎线程和 GUI 渲染线程是互斥的，因此在 JS 执行的时候，UI 页面会被阻塞住。为了在进行高耗时 JS 运算时，UI 页面仍可用，那么就得另外开辟一个独立的 JS 线程来运行这些高耗时的 JS 代码，这就是 Web Worker。

Web Worker 有两个特点：
只能服务于新建它的页面，不同页面之间不能共享同一个 Web Worker。
当页面关闭时，该页面新建的 Web Worker 也会随之关闭，不会常驻在浏览器中。


Service Worker 与 Web Worker 相比，相同点是：它们都是在常规的 JS 引擎线程以外开辟了新的 JS 线程。不同点主要包括以下几点：
Service Worker 不是服务于某个特定页面的，而是服务于多个页面的。（按照同源策略）
Service Worker 会常驻在浏览器中，即便注册它的页面已经关闭，Service Worker 也不会停止。本质上它是一个后台线程，只有你主动终结，或者浏览器回收，这个线程才会结束。
生命周期、可调用的 API 等等也有很大的不同。
总而言之，Service Worker 是 Web Worker 进一步发展的产物。



<!-- https://wangxinyang.xyz/article/60be13de1aa30e0158057912 -->
Service Worker:
处理网络请求的后台服务。完美的离线情况下后台同步或推送通知的处理方案。不能直接与DOM交互。通信（页面和ServiceWorker之间）得通过postMessage方法
Web Worker:
模仿多线程，允许复杂的脚本在后台运行，所以它们不会阻止其他脚本的运行。是保持您的UI响应的同时也执行处理器密集型功能的完美解决方案。不能直接与DOM交互。通信必须通过postMessage方法
WebSocket:
在客户端和服务器之间创建一个开放的连接，允许在一个连接上进行双向通信。是你目前使用长轮询的任何情况，比如聊天软件、在线游戏，或运动代码的完美解决方案。可以直接与DOM交互。通信是通过WebSocket的send方法。

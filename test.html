<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>

        // 1. 封装一个Modal对话框组件，输入是对话框内容html,按钮以及回调
        // 直接引入antdesign的Modal即可实现3个功能。
        // 如果用原生js封装，是一个class, 对话框内容html,按钮以及回调。需要创建元素并处理很多样式问题。
        class Modal {
            constructor(options) {
                const { innerHtml, button, callback } = options
            }
            // 创建 div以及处理样式问题
            creatDom() {
                // 调用HTML的api
                const divOuter = document.createElement('div')
                const divInner = document.createElement('div')
                const ButtonHtml = document.createElement('div')
                divInner.innerHTML = innerHtml
                // 处理样式问题
                divOuter.style = ''
                // 添加事件监听
                ButtonHtml.addEventListener('click', () => {
                    callback()
                    // divOuter display: none
                })
                divOuter.appendChild(divInner)
                divOuter.appendChild(ButtonHtml)
                document.body.appendChild(div)
            }
            open() {
                this.creatDom()
            }
        }


        // 使用的时候 
        const m = new Modal({ innerHtml: 'content', button: 'confirm', callback: () => { } })
        m.open()
        m.close()


        // 2. 防抖截流代码实现
        function debounce(func, wait) {
            var timeout
            return function () {
                var context = this
                var args = arguments
                clearTimeout(timeout)
                timeout = setTimeout(function () {
                    func.apply(context, args)
                }, wait)
            }
        }

        function throttle(func, wait) {
            var context, args
            var previous = 0
            return function (...args) {
                var now = +new Date()
                context = this
                if (now - previous > wait) {
                    func.apply(context, args)
                    previous = now
                }
            }
        }


        // 3. 关系型数组转换成树形结构对象
        function arrToTree(arr, pid = null) {
            let result = []
            arr.forEach(item => {
                if (item.parent === pid) {
                    const children = arrToTree(arr, item.id)
                    if (children.length > 0) {
                        result.push({ ...item, children })
                    } else {
                        result.push({ ...item })
                    }
                }
            })
            return result
        }
        var obj = [
            { "id": 3, "parent": 2 },
            { "id": 1, "parent": null },
            { "id": 2, "parent": 1 }
        ]
        arrToTree(obj)
        // 这里最外层是数组而不是对象 如果需要时对象就处理下
        // o = {
        //     "obj": {
        //         "id": 1,
        //         "parent": null,
        //         "children": [{
        //             "id": 2,
        //             "parent": 1,
        //             "children": [{
        //                 "id": 3,
        //                 "parent": 2
        //             }]
        //         }]
        //     }N
        // }


        // 4. 数组全排列
        // var arr = [["1","2"],["3","4","5"]];
        // 预期结果
        // [["1","3"],["1","4"],["1","5"],["2","3"],["2","4"],["2","5"]]

        function permutate(arr) {
            let res = arr[0].slice();
            for (let i = 1; i < arr.length; i++) {
                const pre = res.slice();
                res = [];
                pre.forEach(item => {
                    arr[i].forEach(curr => {
                        res.push(item + curr)
                    })
                });
            }
            return res;
        }
        permutate([["1","2"],["3","4","5"]])

    </script>
</body>

</html>
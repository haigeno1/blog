<!-- https://juejin.cn/post/7007048306438176799 -->
Vue React对比
    尤雨溪说根本区别是职责范围不同,vue的生态系统可能不会像小职责范围那样多样化。因为小职责范围喜欢把问题抛给社区。而在我们的案例中，很多用户很满意我们的解决方案，同时自己也不用再花费时间去找答案。
    vue template 和 react jsx
        vue 是实现了一套 template 的 DSL，引入了插值、指令、过滤器等模版语法，相对于 jsx 来说更简洁，template 的编译器由 vue 实现。vue template 是受限制的，只能访问 data，prop、method，可以静态的分析和优化。因为和 js 上下文割裂开来，引入 typescript 做类型推导的时候就比较困难，需要单独把所有 prop、method、data 的类型声明一遍才行。
        react 是给 js 扩展了 jsx 的语法，由 babel 实现，可以在描述视图的时候直接用 js 来写逻辑，没啥新语法。 react 的 jsx 因为直接是 js 的语法，动态逻辑比较多，没法静态的做分析和优化。而 react 的 jsx 本来就是和 js 同一个上下文，结合 typescript 就很自然。
        <!-- https://juejin.cn/post/6844903905923448840 -->
        简单点来讲，可以将它看成 JSX 与 Templates，即动态渲染函数和基于静态字符串的复杂的 Vue 表达式。然后就是表现力和原生性能，以及运行时调度和提前优化。
        JSX / VDOM 优点
            JSX 或 VDOM 最重要的原因就是它们具有 JavaScript 的完整表现力。
            它还允许你在渲染组件时将视图层视为数据。因为视图就是是数据，而你可以对数据做任何操作。
        JSX / VDOM 缺点
            VDOM 本身成本真的很高。
            渲染函数的动态特性使得它难以优化。从本质上来说，我们很难通过这种方式对其提供安全的优化。
            最后，React 对于这块的解决方案就是不把重心放在加快 VDOM 本身的速度，而是如何提高感知性能。因此，React 引入了运行时调度并发时间切片的概念，但是这种运行时调度方案，整个 fiber，几乎和我们管理自己的堆栈一样，比如进入和退出渲染，所有的东西都需要很长的运行时间。这意味着无论你何时加载 React，都必须去加载那些用于处理复杂的运行时调度工作的所有必需代码。这就像加载几个20、30KB 大小的 JavaScript 一样。反过来，这也会让你的初始化加载受到一点影响。
        模板编译优点
            根据定义，模板是一种非常有约束的语言，你只能以某种方式去编写模板。如果你是在模板中编译的渲染代码，通常它可以生成一个更加直接的渲染指令，并且具有更好的原生性能。静态（编译）和非常严格的限制实际上是允许编译器对你的意图做更多的预判，从而给它更多的空间去做执行优化。
            所以说，根据策略的不同，模板编译或者基于通用编译的方法也可以使 runtime baseline 更轻量，因为它不需要所有的复杂运行时调度来尝试让事情看起来更快，因为它本身已经很快了。所以 SVELTE 可以产出一个非常轻量的输出，而不需要一个很重的 baseline runtime 来适应所有可能的 runtime 行为。
        模板编译缺点
            你会受限于模板语法，从而失去 JavaScript 的表达能力。
            更轻量的 runtime、更轻量的 baseline runtime，也可能是以每个模板更详细的输出作为代价。因为当你试图去生成尽可能高效的代码时，有时你必须直接在输出的时候编码更多信息。
            如果在运行时编译，则会产生运行时编译成本。因此，对于生产用例来说，最有可能的情况是你需要用户事先编译，这样对于构建步骤来说是一个硬性要求，这是不可避免的，要么在运行中进行编译，要么在预构建中进行编译，其中涉及我们现在或多或少习惯的所有node.js工具链。
    前端框架的数据驱动视图变化的三种思路。watch、脏检查、不检查
        vue 是组件级别的数据 watch，vue 是组件级别的数据监听的方案，问题可能出现在一个属性太多 watcher 的时候，所以优化思路就是大组件拆分成小组件，保证每个属性不要有太多 watcher。
        react 不监听、不检查数据变化，每次都渲染生成 vdom，然后进行 vdom 的对比，那么优化的思路就是 shouldComponentUpdate 来跳过部分组件的 render，而且 react 内部也做了组件树的链表化（fiber）来把递归改成可打断的渲染，按照时间片来逐渐生成整个 vdom。组件树的渲染就是深度优先的，一般是通过递归来做，但是如果能通过链表记录下路径，就可以变成循环。这个通过把组件树改成链表，把 vdom 的生成从递归改循环的功能就是 react fiber。
    组件之间难免要有逻辑的复用（fiber 是解决性能问题的，而 hooks 是解决逻辑复用问题的）
        vue2 的组件内逻辑复用方案就是 mixin，但是 mixin 很难区分混入的属性、方法的来源，比较乱，代码维护性差。
        react 通过 function 组件的 hooks api 解决了 class 组件的逻辑复用方案的问题。react 的组件是 class 和 function 两种形式。HOC 和 render props 是 react 的 class 组件支持的两种逻辑复用方案。react 的组件是 class 和 function 两种形式，那么类似高阶函数的高阶组件（high order component）的方式就比较自然，也就是组件套组件，在父组件里面执行一部分逻辑，然后渲染子组件。HOC的优缺点∶优点∶ 逻辑复用、不影响被包裹组件的内部逻辑。缺点∶ hoc传递给被包裹组件的props容易和被包裹后的组件重名，进而被覆盖. 除了多加一层组件的 HOC 方式以外，没有逻辑的部分可以直接把那部分 jsx 作为 props 传入另一个组件来复用，也就是 render props。render prop 是一个用于告知组件需要渲染什么内容的函数 prop."render prop"是指一种在 React 组件之间使用一个值为函数的 prop 共享代码的简单技术.render props的优缺点也很明显∶优点：数据共享、代码复用，将组件内的state作为props传递给调用者，将渲染逻辑交给调用者.缺点：无法在 return 语句外访问数据、嵌套写法不够优雅.
        function 组件要支持 state，于是 react 就在 function 组件的 fiber 节点中加入了 memorizedState 属性用来存储数据，然后在 function 组件里面通过 api 来使用这些数据，这些 api 被叫做 hooks api。
        Fiber 也称协程或者纤程。它和线程并不一样，协程本身是没有并发或者并行能力的（需要配合线程），它只是一种控制流程的让出机制。让出 CPU 的执行权，让 CPU 能在这段时间执行其他的操作。渲染的过程可以被中断，可以将控制权交回浏览器，让位给高优先级的任务，浏览器空闲后再恢复渲染。
        时间切片，浏览器的每一帧所剩余的时间，链表是的对任务的管控，对于时间的管控是用 自己实现了一套 类似requestAnimation，2个fiber react双缓存机制，
        React.memo, 
        useRef 不会影响视图的更新。
        从优秀的文章入手。
        卡颂，不建议上来就debug。
        fiber 组件如何映射到真实dom上，


    domdiff
        Vue基于snabbdom库，它有较好的速度以及模块机制。Vue Diff使用双向指针，边对比，边更新DOM。
        React主要使用diff队列保存需要更新哪些DOM，得到patch树，再统一操作批量更新DOM。
    事件机制不同
        Vue原生事件使用标准Web事件，Vue组件自定义事件机制，是父子组件通信基础
        React原生事件被包装，所有事件都冒泡到顶层document监听，然后在这里合成事件下发。基于这套，可以跨端使用事件机制，而不是和Web DOM强绑定。React组件上无事件，父子组件通信使用props



    <!-- https://juejin.cn/post/6964779204462247950 -->
    1. Composition API与React Hook很像，区别是什么
        从React Hook的实现角度看，React Hook是根据useState调用的顺序来确定下一次重渲染时的state是来源于哪个useState，所以出现了以下限制
            不能在循环、条件、嵌套函数中调用Hook
            必须确保总是在你的React函数的顶层调用Hook
            useEffect、useMemo等函数必须手动确定依赖关系
        而Composition API是基于Vue的响应式系统实现的，与React Hook的相比
            声明在setup函数内，一次组件实例化只调用一次setup，而React Hook每次重渲染都需要调用Hook，使得React的GC比Vue更有压力，性能也相对于Vue来说也较慢
            Compositon API的调用不需要顾虑调用顺序，也可以在循环、条件、嵌套函数中使用
            响应式系统自动实现了依赖收集，进而组件的部分的性能优化由Vue内部自己完成，而React Hook需要手动传入依赖，而且必须必须保证依赖的顺序，让useEffect、useMemo等函数正确的捕获依赖变量，否则会由于依赖不正确使得组件性能下降。




useState 的参数是函数,函数是立即执行的吗?
hooks状态是存在函数组件对应的fiber节点上，也不是用数组存储，是用链表来存储hook的相关信息.函数组件对应的fiber节点?
有兴趣自己实现一个每秒加一的计数器效果
useEffect在浏览器渲染结束后执行，useLayoutEffect 则是在dom更新后，浏览器绘制前执行。


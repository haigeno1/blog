// https://zhuanlan.zhihu.com/p/378346507
// https://zhuanlan.zhihu.com/p/343453960

iframe 就相当于页面里再开个窗口加载别的页面，但是它有很多弊端：
  每次进来都要加载，状态不能保留
  DOM 结构不共享。比如子应用里有一个 Modal，显示的时候只能在那一小块地方展示，不能全屏展示
  无法跟随浏览器前进后退
  天生的硬隔离，无法与主应用进行资源共享，交流也很困难
而 SPA 正好可以解决上面的问题：
  切换路由就是切换页面组件，组件的挂载和卸载非常快
  单页应用肯定共享 DOM
  前端控制路由，想前就前，想后就后
  React 通信有 Redux，Vue 通信有 Vuex，可与 App 组件进行资源共享，交流很爽
  这就给我们一个启发：能不能有这么一个巨型 SPA 框架，把现有的 SPA 当成 Page Component 来组装成一个新的 SPA 呢？这就是微前端的由来。


微前端应该有如下特点：
  技术栈无关，主框架不限制接入应用的技术栈，微应用具备完全自主权
  独立开发、独立部署，微应用仓库独立，前后端可独立开发，部署完成后主框架自动完成同步更新
  增量升级，在面对各种复杂场景时，我们通常很难对一个已经存在的系统做全量的技术栈升级或重构，而微前端是一种非常好的实施渐进式重构的手段和策略
  独立运行时，每个微应用之间状态隔离，运行时状态不共享
single-spa 框架并没有实现上面任何特点，对的，一个都没有，Just Zero。single-spa 仅仅是一个子应用生命周期的调度者。single-spa 为应用定义了 boostrap, load, mount, unmount 四个生命周期回调：
single-spa 的大致框架了，无非就两件事：
  实现一套生命周期，在 load 时加载子 app，由开发者自己玩，别的生命周期里要干嘛的，还是由开发者造的子应用自己玩
  监听 url 的变化，url 变化时，会使得某个子 app 变成 active 状态，然后走整套生命周期
SystemJS 的好处和优势有且仅有一点：那就是在浏览器里使用 ES6 的 import/export。SystemJS 另一个好处就是可以通过 importmap 引入公共依赖。






应用的 JS 隔离本质是什么，本质其实就是在 B 子应用里使用 window 全局对象里的变量时，不要被 A 子应用给污染了。

single-spa-css 解决了子应用的 CSS 引入和移除问题，但是又带来了另一个问题：怎么保证各个子应用的样式不互相干扰呢
single-spa-layout
  和 Vue Router 差不多，主要功能是可以在 index.html 指定在哪里渲染哪个子应用。

single-spa-react, single-spa-xxx....
  给子应用快速生成 bootstrap, mount, unmount 的生命周期函数的工具库。

single-spa-css
  隔离前后两个子应用的 CSS 样式。
如果要在多个子应用进行样式隔离，可以有两种方法：
  Shadow DOM，样式隔离比较好的方法，但是穿透比较麻烦
  Scoped CSS，在子应用的 CSS 选择器上添加前缀做区分，可以使用 postcss-prefix-selector 这个包来快速添加前缀
  



  

  简单描述下就是基座应用中有一些菜单项，点击每个菜单项可以展示对应的微应用，这些应用的切换是纯前端无感知的，所以，基于目前的方案来说，一个微前端的基座框架需要解决以下问题：

  路由切换的分发问题。
  主微应用的隔离问题。
  通信问题。
  下面针对这些问题来一一阐述。
  
  微前端的路由分发
  作为微前端的基座应用，是整个应用的入口，负责承载当前微应用的展示和对其他路由微应用的转发，对于当前微应用的展示，一般是由以下几步构成：
  
  
  
  作为一个SPA的基座应用，本身是一套纯前端项目，要想展示微应用的页面除了采用iframe之外，要能先拉取到微应用的页面内容， 这就需要远程拉取机制。
  远程拉取机制通常会采用fetch API来首先获取到微应用的HTML内容，然后通过解析将微应用的JavaScript和CSS进行抽离，采用eval方法来运行JavaScript，并将CSS和HTML内容append到基座应用中留给微应用的展示区域，当微应用切换走时，同步卸载这些内容，这就构成的当前应用的展示流程。
  当然这个流程里会涉及到CSS样式的污染以及JavaScript对全局对象的污染，这个涉及到隔离问题会在后面讨论，而目前针对远程拉取机制这套流程，已有现成的库来实现，可以参考import-html-entry和system.js。
  
  
  对于路由分发而言，以采用vue-router开发的基座SPA应用来举例，主要是下面这个流程：
  
  
  
  当浏览器的路径变化后，vue-router会监听hashchange或者popstate事件，从而获取到路由切换的时机。
  最先接收到这个变化的是基座的router，通过查询注册信息可以获取到转发到那个微应用，经过一些逻辑处理后，采用修改hash方法或者pushState方法来路由信息推送给微应用的路由，微应用可以是手动监听hashchange或者popstate事件接收，或者采用React-router，vue-router接管路由，后面的逻辑就由微应用自己控制。
  
  
  微前端的应用隔离
  
  应用隔离问题主要分为主应用和微应用，微应用和微应用之间的JavaScript执行环境隔离，CSS样式隔离，我们先来说下CSS的隔离。
  
  CSS隔离：当主应用和微应用同屏渲染时，就可能会有一些样式会相互污染，如果要彻底隔离CSS污染，可以采用CSS Module 或者命名空间的方式，给每个微应用模块以特定前缀，即可保证不会互相干扰，可以采用webpack的postcss插件，在打包时添加特定的前缀。
  
  而对于微应用与微应用之间的CSS隔离就非常简单，在每次应用加载时，将该应用所有的link和style 内容进行标记。在应用卸载后，同步卸载页面上对应的link和style即可。
  
  JavaScript隔离：每当微应用的JavaScript被加载并运行时，它的核心实际上是对全局对象Window的修改以及一些全局事件的改变，例如jQuery这个js运行后，会在Window上挂载一个window.$对象，对于其他库React，Vue也不例外。为此，需要在加载和卸载每个微应用的同时，尽可能消除这种冲突和影响，最普遍的做法是采用沙箱机制（SandBox）。
  
  沙箱机制的核心是让局部的JavaScript运行时，对外部对象的访问和修改处在可控的范围内，即无论内部怎么运行，都不会影响外部的对象。通常在Node.js端可以采用vm模块，而对于浏览器，则需要结合with关键字和window.Proxy对象来实现浏览器端的沙箱。
  
  微前端的消息通信
  应用间通信有很多种方式，当然，要让多个分离的微应用之间要做到通信，本质上仍离不开中间媒介或者说全局对象。所以对于消息订阅（pub/sub）模式的通信机制是非常适用的，在基座应用中会定义事件中心Event，每个微应用分别来注册事件，当被触发事件时再有事件中心统一分发，这就构成了基本的通信机制，流程如下图：





qiankun
为了填平 single-spa 遗留下来的坑，阿里基于 single-spa 造出了 qiankun 微前端框架，真正实现了微前端的所有特性，不过这又是另外一个故事了。
<!-- https://zhuanlan.zhihu.com/p/541391922 -->
状态管理redux react-redux recoil mobx
Redux 遵循此模型，并要求所有状态更新都以不可变的方式完成。做这样的选择需要权衡取舍。在这种情况下，一个常见的缺点是对那些习惯于可变方式更新的人来说必须要编写大量样板代码来进行更新。
Redux 倾向于吸收所有状态，无论其是什么类型，因为它提倡使用单一存储。这就会导致将所有东西都存储在一个超大的单一存储中。这往往会引出第二个问题，运行时性能优化。因为 Redux 通常只处理全局共享状态，所以很多这些子问题都需要反复处理（或者通常无人关注）。这导致形成一个大型单一存储，在一个地方管理 UI 和远程实体状态之间的所有内容。


我们可以看到之前的状态管理解决方案（如 Redux）在他们的实现上比较「自上而下」。随着时间的推移，它倾向于吸收组件树顶部的所有状态。状态都在树的顶部，下面的组件通过选择器获取它们需要的状态。
在 构建面向未来的前端架构 中，我们看到了自下而上的模式在构建具有组合模式的组件方面的作用。
hooks 既提供也提倡了将可组合部件组合在一起形成更大整体的原则。使用 hooks，标志着巨型单一全局存储的状态管理方法的转变。走向自下而上的「微」状态管理，强调通过 hooks 消费更小的状态片段。
像 Recoil 和 Jotai 这样的流行库用他们的「原子」状态概念来验证了这种自下而上的方法。
Jotai 是一个典型的 Component State 管理库
原子是很小但完整的状态单位。它们是状态的一小块，可以连接在一起形成新的派生状态。这样最终就会形成一个关系图。
这套模型允许开发者以自下而上的方式逐步构建状态。并可以通过只让关系图中已更新的原子状态无效来优化重复渲染。这与直接订阅一个巨型的单一状态形成对比，并可以尽量减少不必要的重复渲染。


<!-- https://www.ccc5.cc/2912.html -->
当实现一个在 React 体系下的状态管理库时，不得不考虑这些问题：
* 状态放哪里：模块内 or 组件内
* 是否需要支持多实例
* 如何避免额外的渲染
* 如何支持异步
* 如何表达 Derived State
* 如何让语法更简单，用户使用心智最低
Component State 依托于 react 生命周期而存在的状态，随 React 组件树创建与销毁，其优点在于容易划分多实例，无需操心内存泄漏，而缺点在于无法方便在组件树之外读写数据，Jotai 是一个典型的 Component State 管理库
Module State 是存在于 ES Module 内的状态，独立于 React，需要手动管理器生命周期，优缺点刚好与 Component State 反之，Redux 则是 Module State 的代表